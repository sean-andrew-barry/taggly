import {Docs} from "/js/Tags/Page/Docs.js";
import {Div} from "/js/Tags/Div.js";
import {Label} from "/js/Tags/Label.js";
import {Input} from "/js/Tags/Input.js";
import {Form} from "/js/Tags/Form.js";
import {H1} from "/js/Tags/H1.js";
import {H3} from "/js/Tags/H3.js";
import {P} from "/js/Tags/P.js";
import {A} from "/js/Tags/A.js";
import {Em} from "/js/Tags/Em.js";
import {Aside} from "/js/Tags/Aside.js";
import {UL} from "/js/Tags/UL.js";
import {LI} from "/js/Tags/LI.js";
import {Strong} from "/js/Tags/Strong.js";
import {Pre} from "/js/Tags/Pre.js";
import {Span} from "/js/Tags/Span.js";
import {Emoji} from "/js/Tags/Img/Emoji.js";

import {UsingOnFunctionCounter} from "/js/Tags/Page/Docs/Examples/UsingOnFunctionCounter.js";
import {UsingOnFunctionInConstructor} from "/js/Tags/Page/Docs/Examples/UsingOnFunctionInConstructor.js";
import {UsingSymbolFunction} from "/js/Tags/Page/Docs/Examples/UsingSymbolFunction.js";
import {UsingVisibilityEvents} from "/js/Tags/Page/Docs/Examples/UsingVisibilityEvents.js";

import {FullHD} from "/js/Event/FullHD.js";
import {Widescreen} from "/js/Event/Widescreen.js";
import {Desktop} from "/js/Event/Desktop.js";
import {Tablet} from "/js/Event/Tablet.js";
import {Mobile} from "/js/Event/Mobile.js";

export class UsingEvents extends Docs
{
  static GetMetaURL(){ return import.meta.url; }
  static GetLocalName(){ return "using-events"; }
  static GetTitle(){ return "Using events"; }
  static GetNext(){}
  static GetURL(...parts){ return super.GetURL(UsingEvents.GetLocalName(), ...parts); }

  get on(){ return this.Code().Text("On"); }
  get tag(){ return this.Code().Text("Tag"); }
  get self(){ return this.Code().Text("self"); }
  get event(){ return this.Code().Text("Event"); }
  get click(){ return this.Code().Text("Click"); }
  get symbol(){ return this.Code().Text("Symbol"); }
  get addEventListener(){ return this.Code().Text("addEventListener"); }
  get click_class(){ return this.Code().Text("Click"); }
  get to_primitive(){ return this.Code().Text("Symbol.toPrimitive"); }
  get mutation_observer(){ return this.Code().Text("MutationObserver"); }
  get connect(){ return this.Code().Text("Connect"); }
  get disconnect(){ return this.Code().Text("Disconnect"); }
  get moved(){ return this.Code().Text("Moved"); }
  get attribute(){ return this.Code().Text("Attribute"); }
  get character_data(){ return this.Code().Text("CharacterData"); }
  get view_enter(){ return this.Code().Text("ViewEnter"); }
  get view_leave(){ return this.Code().Text("ViewLeave"); }
  get full_view_enter(){ return this.Code().Text("FullViewEnter"); }
  get full_view_leave(){ return this.Code().Text("FullViewLeave"); }
  get redraw(){ return this.Code().Text("Redraw"); }
  get render(){ return this.Code().Text("Render"); }

  get full_hd(){ return this.Code().Text("FullHD"); }
  get widescreen(){ return this.Code().Text("Widescreen"); }
  get desktop(){ return this.Code().Text("Desktop"); }
  get tablet(){ return this.Code().Text("Tablet"); }
  get mobile(){ return this.Code().Text("Mobile"); }

  get not_full_hd(){ return this.Code().Text("NotFullHD"); }
  get not_widescreen(){ return this.Code().Text("NotWidescreen"); }
  get not_desktop(){ return this.Code().Text("NotDesktop"); }
  get not_tablet(){ return this.Code().Text("NotTablet"); }
  get not_mobile(){ return this.Code().Text("NotMobile"); }

  get x(){ return this.Code().Text("x"); }
  get y(){ return this.Code().Text("y"); }
  get width(){ return this.Code().Text("width"); }
  get height(){ return this.Code().Text("height"); }

  RenderUsingEventsSection()
  {
    return [
      this.SubTitle().Text("The On function"),

      P.TL`Events are a big part of developing in JavaScript, and so of course they are also a big part of developing in ${this.taggly}.`,

      P.TL`The default way you listen to an event is by using the ${this.on} function. Here's an example:`,

      this.Pre().Fetch("/js/Tags/Page/Docs/Examples/UsingOnFunctionCounter.js"),

      P.TL`And here is the button generated by the default function:`,

      this.Example().Add(
        UsingOnFunctionCounter(),
      ),

      P.TL`The ${this.on} function is pretty easy to understand. It just calls the standard ${this.addEventListener} function. The first parameter to ${this.on} is usually an ${this.event} object (more on that in a moment), but it can also be a string, like:`,

      this.Pre().Type("js").TL`new Button().On("click", (event, self) => \n{\n  ...\n});`.Parse(),

      P.TL`The ${this.self} parameter passed to the event handler is just the tag that has the event. In this case, it's the Button.`,
    ];
  }

  RenderTheEventClassSection()
  {
    return [
      this.SubTitle().Text("The Event class"),

      P.TL`${this.taggly} has a class for each ${this.event}. The ${this.click_class} above is one of them. These allow us to do some very convenient things. See, calling the ${this.on} function is great for when you're defining lots of tags inside a function, but it's less good when we want to create our own ${this.tag} classes. Here's an example of what I mean:`,

      this.Pre().Fetch("/js/Tags/Page/Docs/Examples/UsingOnFunctionInConstructor.js"),

      this.Example().Add(
        new UsingOnFunctionInConstructor(),
      ),

      P.TL`Using the ${this.on} function like that is ${Em.Text("fine")}, it will get the job done, but it isn't really ideal. So, I created a different way!`,

      this.Pre().Fetch("/js/Tags/Page/Docs/Examples/UsingSymbolFunction.js"),

      this.Example().Add(
        new UsingSymbolFunction(),
      ),

      P.TL`Now this syntax might look pretty weird, but it's actually completely normal and valid JavaScript! What's happening is that the base ${this.event} class defines a static ${this.to_primitive} method. When the JavaScript engine reaches the ${this.Code().TL`[Click]`} portion, it automatically checks if the object has a ${this.to_primitive} function, and calls it. The ${this.event}'s ${this.to_primitive} function returns a unique ${this.symbol} instead of a string.`,

      P.TL`What this means is that any event class can be represented completely uniquely on any class, by using its ${this.symbol}. I ${Em.Text("could")} have designed the event system to check for a function named "Click" on the tag, but using a string runs the risk of collisions. What if you already had a "Click" function that was doing something entirely different? Suddenly the ${this.click} event would be invoking your function. That wouldn't be good. The ${this.symbol} system means we will never have this problem!`,

      this.Note().TL`Doing events in this way also has slightly better performance, since it does not have to register an event listener.`,
    ];
  }

  RenderSpecialEventsSection()
  {
    return [
      this.SubTitle().Text("Taggly's custom events"),

      P.TL`${this.taggly} supports all the standard DOM events. But it also implements a lot of custom events which are very useful! I'll go through some of the most common and most useful ones.`,

      this.MiniTitle().Text("Mutation events"),

      P.TL`First, let's talk about ${this.connect}, ${this.disconnect}, and ${this.moved} events:`,

      this.Pre().Fetch("/js/Tags/Page/Docs/Examples/UsingMutationEvents.js"),

      P.TL`When a tag gets added into the DOM, a ${this.connect} event gets fired on it. When a tag gets removed, a ${this.disconnect} event is fired. And finally, when a tag gets both removed and added to the DOM in a single update, the ${this.moved} event is fired instead of firing ${this.disconnect} then ${this.connect}.`,

      this.Note().TL`Internally, ${this.taggly} is using a standard ${this.mutation_observer} to generate these events. The ${this.moved} event only happens if a tag is both added ${Em.TL`and`} removed in the same mutation.`,

      P.TL`Next, the ${this.attribute} event fires whenever a tag's attributes are changed. Similarly, the ${this.character_data} event fires when a tag's text content changes.`,

      this.MiniTitle().Text("Visibility events"),

      P.TL`The ${this.view_enter} and ${this.view_leave} are also very useful. They trigger when a tag becomes visible on the screen and then when a tag stops being visible on the screen.`,

      P.TL`${this.full_view_enter} and ${this.full_view_leave} are very similar to the two events above, except that they require the tag to be entirely in or entirely out of the viewport, not just partially visible.`,

      P.TL`Here's an example of ${this.full_view_enter} and ${this.full_view_leave} in action:`,

      this.Pre().Fetch("/js/Tags/Page/Docs/Examples/UsingVisibilityEvents.js"),

      P.TL`And here's the result of the above code. To see the events in action, scroll your browser either up or down until the box below is partially off screen.`,

      this.Example().Add(
        new UsingVisibilityEvents(),
      ),

      this.MiniTitle().Text("The Render event"),

      P.TL`The ${this.render} event is pretty simple. It fires whenever a tag ${this.B`first`} shows on screen. It only fires ${this.B`once`} per tag. This makes it useful for doing initial styling of a tag, because it only happens once, and only when it actually shows up on the screen. If it never actually renders, there's no need to waste processing time setting up its styles!`,

      this.MiniTitle().Text("The Redraw event"),

      P.TL`The ${this.redraw} event is one of my favorites. It triggers whenever a visible tag's ${this.x}, ${this.y}, ${this.width}, or ${this.height} change. In other words, if a tag gets moved or resized, ${this.redraw} will fire. This is very useful when doing more complex dynamic styling.`,

      this.Note().Add(
        P.TL`Note that if you do anything that change's a tag's ${this.x}, ${this.y}, ${this.width}, or ${this.height} from inside a ${this.redraw} event, it will cause another ${this.redraw} event to be fired on the next update. Here's an example:`,

        this.Pre().Fetch("/js/Tags/Page/Docs/Examples/InfiniteRedrawLoop.js"),

        P.TL`In the above code, the ${this.redraw} event will be fired every single frame for as long as that tag is visible in the DOM. This isn't necessarily a ${this.I`bad`} or ${this.I`good`} thing. It's just something to be aware of.`,
      ),

      this.MiniTitle().Text("Resizing events"),

      P.TL`The final custom events I want to mention are the resizing events. These are ${this.full_hd}, ${this.widescreen}, ${this.desktop}, ${this.tablet}, and ${this.mobile}. Each of these events triggers when the browser window's width crosses a certain point.`,

      new Div()
      .DisplayGrid()
      .GridTemplateColumns("auto auto auto auto auto 1fr")
      .ColumnGap("1em")
      .MarginTop("1em")
      .MarginLeft("1em")
      .Add(
        ...this.RenderResizeEventRow(this.full_hd, ">=", FullHD),
        ...this.RenderResizeEventRow(this.widescreen, ">=", Widescreen),
        ...this.RenderResizeEventRow(this.desktop, ">=", Desktop),
        ...this.RenderResizeEventRow(this.tablet, ">=", Tablet),
        ...this.RenderResizeEventRow(this.mobile, "<", Mobile),
      ),

      P.TL`But you can custom these events to whatever values you like, or even add more of them.`,

      P.TL`Each of these events also have the inverse version:`,

      new Div()
      .DisplayGrid()
      .GridTemplateColumns("auto auto auto auto auto 1fr")
      .ColumnGap("1em")
      .MarginTop("1em")
      .MarginLeft("1em")
      .Add(
        ...this.RenderResizeEventRow(this.not_full_hd, ">=", FullHD, true),
        ...this.RenderResizeEventRow(this.not_widescreen, ">=", Widescreen, true),
        ...this.RenderResizeEventRow(this.not_desktop, ">=", Desktop, true),
        ...this.RenderResizeEventRow(this.not_tablet, ">=", Tablet, true),
        ...this.RenderResizeEventRow(this.not_mobile, "<", Mobile, true),
      ),

      this.Note().Add(
        P.TL`Note that the resize event system is going to be heavily reworked in the future and become a lot more specific and useful. ${Emoji.Smile().Style()}`,
      ),
    ];
  }

  RenderResizeEventRow(code, operation, event, invert = false)
  {
    // if (invert === true)
    // {
    //   if (operation === ">=")
    //   {
    //     operation = "<";
    //   }
    //   else if (operation === "<")
    //   {
    //     operation = ">=";
    //   }
    // }

    return [
      new LI().MarginRight("-1.5em"),
      Span.Add(code),
      Span.TL`fires if the width is${invert === true ? Strong.Text(" not") : ""}`,
      // Span.TL`fires if the width is`,
      Span.Text(operation).Color("#9980fa").FontFamilyMonoSpace(),
      Span.Add(event.GetWidth()),
      Span.Add("pixels"),
    ];
  }

  RenderHTML()
  {
    return [
      // this.Pre().Type("html").Text(`<button class="button">\n  <span>Button</span>\n</button>`),
      // this.Pre().Type("html").Text(HTML_TEXT),
      // this.Pre().Type("css").Text(CSS_TEXT),
      // this.Pre().Type("js").Text(JAVASCRIPT_TEXT),
      // this.Pre().Type("js").Fetch("/js/Tags/Page/Docs/Examples/UsingOnFunctionCounter.js"),
      this.Pre().Type("js").Fetch("/js/Tags/Page/Docs/Examples/ExampleJS.js"),
      // this.Pre().Type("html").Text(`<title class="title">Title - Website</title>`),
      // this.Pre().Type("html").Text(`<button></button>`),
      // this.Pre().Type("html").Fetch("/js/Tags/Page/Docs/Examples/ExampleHTML.js"),
    ];
  }

  Render()
  {
    return super.Render(
      new Form().Append(
        this.Title().Text("Using events"),

        ...this.RenderUsingEventsSection(),
        ...this.RenderTheEventClassSection(),
        ...this.RenderSpecialEventsSection(),
      ),
    );
  }
}
